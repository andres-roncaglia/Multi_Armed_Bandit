---
title: "La Guía del Apostador"
subtitle: "Trabajo Práctico Nº1"
format: pdf
lang: es
toc: true
toc-title: Indice
echo: FALSE
message: FALSE
warning: FALSE
geometry:
  - top= 25mm
  - left= 20mm
  - right = 20mm
  - bottom = 25mm
  - heightrounded
---

```{r Carga de librerias}
library(tidyverse)
library(RColorBrewer)
```

```{r Configuraciones predeterminadas}
knitr::opts_chunk$set(fig.align = "center", out.width = "70%")

set.seed("18122022")

theme_set(theme_bw())

```

\newpage

# Introducción

En los casinos uno de los juegos más llamativos son las máquinas tragamonedas o tragaperras. También conocido por ser uno de los juegos más adictivos en el mundo de las apuestas y en el cual las personas pierden más dinero. Con el fin de que estas personas pierdan menos dinero se estudiará la eficacia de distintas estrategias de juego. A este problema se lo conoce como "Bandido Multibrazo" (*Multi armed bandit*).

La principal incógnita se encuentra en descubrir hasta que punto conviene "explotar" por sobre "explorar" o viceversa. Explotar refiere a dar prioridad a elegir lo que sabemos que funciona, mientras que explorar refiere a ser propenso a salir de la "zona de confort" y buscar nuevas alternativas.

# Metodología

Se plantea que se tienen 3 máquinas tragamonedas con distintas probabilidades de ganar una unidad monetaria, las cuales son:

-   $\theta_A = 0.30$
-   $\theta_B = 0.55$
-   $\theta_C = 0.45$

Cada día se hará una sola tirada en una máquina que será elegida según la estrategia, durante los 366 días del año 2024, con el objetivo de ganar la mayor cantidad de dinero posible, teniendo en cuenta que no cuesta dinero jugar, es decir, solo podemos ganar dinero.

Se asume además que la creencia inicial de la probabilidad de ganar para cada máquina sigue una distribución $Beta(2,2)$, la cual se puede observar a continuación.

```{r prior}
thetas <- seq(0,1,length.out = 1000)

prior <- dbeta(thetas,2,2)
```


```{r prior fig}
#| fig-cap: "Distribución a priori de la probabilidad de éxito inicial para todas las máquinas."

tibble(thetas, prior) |>

  ggplot() +

  geom_line(aes(x = thetas, y = prior),

            color = "dodgerblue4",

            linewidth = 1) +

  labs(x = expression(theta), y = "Probabilidad") +

  geom_hline(yintercept = 0, color = "black", size = 0.2) +

  geom_vline(xintercept = 0, color = "black", size = 0.2)

```



\newpage
# Resultados

Para obtener una noción de cuanto se ganaría en promedio en un año de juego con la mejor máquina (máquina B), se simulan 1000 secuencias de 366 juegos.



```{r primer punto}
n <- 1000

ganancias <- NULL

for (i in 1:n) {

  ganancias[i] <- sum(rbinom(366, size = 1, prob = 0.55))

}

promedio_ganancias <- mean(ganancias)
```


```{r primer punto fig}
#| fig-cap: "Distribución de las unidades monetarias ganadas en un año con la máquina B."

tibble(ganancias) |>

  ggplot() +

  geom_histogram(aes(x = ganancias),

                 bins = 30,

                 fill = "dodgerblue3",

                 color = "black") +

  labs(x = "Unidades monetarias", y = "Frecuencias") +

  geom_hline(yintercept = 0, color = "black", size = 0.2)
```



Resultando `r round(promedio_ganancias, 2)` una estimación de la ganancia esperada durante un año de juego con la máquina B.



## Estrategias

Sin embargo las personas no tienen información acerca de las probabilidades de éxito de las máquinas, por lo que se diseñaron un conjunto de estrategias para descubrir con cúal se obtienen mejores resultados. 


```{r cargamos las funciones}
source("Estrategias_y_simulacion.R")
```

::: {.callout-note}
## Función simulación

```{r funcion simulacion, echo=TRUE, eval=FALSE}
# n simulaciones de los 366 dias, jugando 1 vez por día
simulacion <- function(metodo, n = 1, param = 0.2) {
  
  if(!(metodo %in% names(estrategias))){
    stop("El método introducido no está especificado")
  }
  if(n<1 || (n != round(n))){
    stop("La cantidad de simulaciones debe ser un número natural")
  }
  if(metodo == "softmax" && param <= 0){
    stop("Para el método softmax el parámetro de temperatura debe ser mayor que 0")
  }
  if(metodo == "e_greedy" && (param < 0 || param > 1)){
    stop("Para el método e-greedy el parámetro epsilon debe estar entre 0 y 1")
  }
  
```
:::

::: {.callout-note}
##  ‎ ‎ ‎
```{r funcion simulacion 2, echo=TRUE, eval=FALSE}
# Creamos los vectores donde guardaremos las ganancias y maquinas de los 366 
  # dias para cada repeticion. Creamos tambien una futura lista llamada sim que
  # va a guardar las ganancias y las maquinas usadas en las repeticiones
  
  ganancias <- NULL
  maquinas <- NULL
  sim <- NULL

  # Hacemos n repeticiones
  for (rep in 1:n) {
    
    #Creamos los vectores que guardaran las ganancias y las maquinas usadas en 
    # cada dia
    ganancia <- numeric(length = 366)
    maquina <- NULL
    for (dia in 1:366) {
      
      # Para cada dia la maquina sera elegida con alguno de las estrategias 
      # diseñadas
      argumentos <- switch (metodo,
                            "al_azar" = list(),
                            "gcto" = list(maquina, ganancia),
                            "gcpp" = list(maquina, ganancia),
                            "e_greedy" = list(maquina, ganancia, param),
                            "softmax" = list(maquina, ganancia, param),
                            "thompson" = list(maquina, ganancia),
                            "upper_bound" = list(maquina, ganancia, param)
                            )
      
      maquina_dia <- do.call(estrategias[[metodo]], argumentos)
      
            # una vez elegida la maquina simulamos con una bernoulli con la 
      # probabilidad de la maquina y guardamos el resultado
      ganancia[dia] <- rbinom(1, size = 1, prob = prob_reales[maquina_dia])
      
      # Guardamos ademas la maquina utilizada
      maquina[dia] <- maquina_dia
    }
```
:::

::: {.callout-note}
##  ‎ ‎ ‎
```{r funcion simulacion 3, echo=TRUE, eval=FALSE}
    # Guardamos en matrices las ganancias y las maquinas de los 366 dias
    # de las diferentes repeticiones
    ganancias <- cbind(ganancias, ganancia)
    maquinas <- cbind(maquinas, maquina)
    
  }  
  
  #Transformamos las matrices en tibbles, y les asignamos nombres a las columnas
  # segun el repeticion
  ganancias <- as_tibble(ganancias)
  maquinas <- as_tibble(maquinas)
  
  colnames(ganancias) <- paste0("Rep_",1:1000)
  colnames(maquinas) <- paste0("Rep_",1:1000)
  
  # Añadimos los tibbles a la lista
  sim[["Ganancias"]] <- ganancias
  sim[["Maquinas"]] <- maquinas
  
  # Devolvemos la lista
  sim 
}

```


:::

\

### Completamente al azar

Consiste en elegir cada día una máquina cualquiera sin importar los resultados que se hayan obtenido en el día anterior. Esta estrategia se concentra únicamente en "explorar" pero nunca considera "explotar" como una posibilidad.

Para elegir la máquina con la que se va a jugar en el día se hizo uso de la siguiente función:

::: {.callout-note}
## Función al_azar

```{r funcion al azar, echo=TRUE, eval=FALSE}

# Estrategia al azar
al_azar <- function() {
  # Elige una maquina al azar
  sample(names(prob_reales), 1)
}

```


:::
\newpage
Simulando los 366 días de juego:

```{r sim al azar}
sim <- simulacion("al_azar", n = 1)

salida <- salidas(sim)


```

```{r al azar grafico_ganancias_acumuladas}
#| fig-cap: "Unidades monetarias acumuladas durante un año con la estrategia al azar."

salida$grafico_ganancias_acumuladas
```

Se observa que se ganaron `r max(salida$ganancias_acumuladas)` unidades monetarias en el año.

```{r al azar grafico_barplot}
#| fig-cap: "Frecuencia, éxito y fracaso para cada máquina durante un año con la estrategia al azar."

salida$grafico_barplot

maquina_mas_jugada <- salida$tabla_barplot |> group_by(Maquina) |> summarise(n = sum(Cantidad)) |> filter(n == max(n)) |> select(Maquina) |> as.character() 

```

`r ifelse(length(maquina_mas_jugada) == 1, paste("La máquina más jugada fue la", maquina_mas_jugada) ,paste("Las máquinas más jugadas fueron las", paste(maquina_mas_jugada, collapse = " y ")))`


```{r al azar grafico_posteriors}
#| fig-cap: "Probabilidades de éxito para cada máquina a posteriori luego de un año con la estrategia al azar."

salida$grafico_posteriors
```

Y así resultan las distribuciones de la probabilidad de éxito en cada máquina a posteriori. 

Ventajas de la estrategia:

  - No se corre el riesgo de concentrarse demasiado en una máquina que produciría menos ganancias.
  
Desventajas de la estrategia:

  - No tiene en cuenta la información que se adquiere a través de los días.

\newpage
### Greedy con tasa observada

La máquina con la que se juega será la que tenga la mayor tasa de éxito hasta el dia en que se juega. Esta estrategia se concentra demasiado en "explotar" y casi nada en "explorar".

Para elegir la máquina con la que se va a jugar en el día se hizo uso de la siguiente función:

::: {.callout-note}
## Función gcto

```{r funcion gcto, echo=TRUE, eval=FALSE}


# Greedy con tasa observada
gcto <- function(maquina, ganancia) {
  
  # Las tazas son 0 en la primera iteracion
  tasa <- numeric(3)
  
  
  # Cuando una maquina no se usa ni una vez, la tasa va a seguir siendo 0
  # Cuando se juegue al menos una vez su tasa será el numero de veces que gano 
  # en la maquina dividido la cantidad de veces que jugo con la maquina
  if (sum(maquina == "A") > 0) {
    tasa[1] <- sum(ganancia[maquina == "A"])/sum(maquina == "A")
  }
  if (sum(maquina == "B") > 0) {
    tasa[2] <- sum(ganancia[maquina == "B"])/sum(maquina == "B")
  }
  if (sum(maquina == "C") > 0) {
    tasa[3] <- sum(ganancia[maquina == "C"])/sum(maquina == "C")
  }
  
  # Se asigna el nombre de la maquina para cada tasa
  names(tasa) <- c("A","B","C")
  
  # Verifica cual es la tasa mas alta y la elige, si hay una sola elige la 
  # maquina a la cual le pertenezca esa tasa, si hay varias maquinas con la misma 
  # tasa elige una al azar entre las que tengan la mayor tasa
  
  if (sum(tasa == max(tasa)) == 1) {
    maq <- names(tasa[which.max(tasa)])
  } else {
    maq <- sample(names(tasa[tasa == max(tasa)]), size = 1)
  }
  
  return(maq)
}



```
:::

\newpage
Simulando los 366 días de juego:

```{r sim gcto}
sim <- simulacion("gcto", n = 1)

salida <- salidas(sim)


```

```{r gcto grafico_ganancias_acumuladas}
#| fig-cap: "Unidades monetarias acumuladas durante un año con la estrategia greedy con tasa observada."

salida$grafico_ganancias_acumuladas
```

Se observa que se ganaron `r max(salida$ganancias_acumuladas)` unidades monetarias en el año.

```{r gcto grafico_barplot}
#| fig-cap: "Frecuencia, éxito y fracaso para cada máquina durante un año con la estrategia greedy con tasa observada."

salida$grafico_barplot

maquina_mas_jugada <- salida$tabla_barplot |> group_by(Maquina) |> summarise(n = sum(Cantidad)) |> filter(n == max(n)) |> select(Maquina) |> as.character() 

```

`r ifelse(length(maquina_mas_jugada) == 1, paste("La máquina más jugada fue la", maquina_mas_jugada) ,paste("Las máquinas más jugadas fueron las", paste(maquina_mas_jugada, collapse = " y ")))`

\newpage
```{r gcto grafico_posteriors}
#| fig-cap: "Probabilidades de éxito para cada máquina a posteriori luego de un año con la greedy con tasa observada."

salida$grafico_posteriors
```

Y así resultan las distribuciones de la probabilidad de éxito en cada máquina a posteriori. 

Ventajas de la estrategia:

  - En algunos escenarios es posible elegir siempre la mejor máquina.
  
Desventajas de la estrategia:

  - Una vez que se gane con una máquina, se elegirá siempre esa misma.
  
  - Es posible elegir explotar la peor máquina.


\newpage
### Greedy con probabilidad a posteriori

Partiendo de las creencias iniciales, luego de cada tirada y considerando las realizadas hasta el momento, se redefinen las probabilidades de éxito esperadas de cada máquina y se selecciona la mejor. 

Para elegir la máquina con la que se va a jugar en el día se hizo uso de la siguiente función:

::: {.callout-note}
## Función gcpp

```{r funcion gcpp, echo=TRUE, eval=FALSE}

# Greedy con probabilidad a posteriori

gcpp <- function(maquina, ganancia) {
  
  # Argumentos de las distribuciones de los parámetros
  a1 <- 2; b1 <- 2; c1 <- 2; a2 <- 2; b2 <- 2; c2 <- 2
  
  if (sum(maquina == "A") > 0) {
    a1 <- 2 + sum(ganancia[maquina == "A"])
    a2 <- 2 + abs(sum(ganancia[maquina == "A"] -1))
  }
  if (sum(maquina == "B") > 0) {
    b1 <- 2 + sum(ganancia[maquina == "B"])
    b2 <- 2 + abs(sum(ganancia[maquina == "B"] -1))
  }
  if (sum(maquina == "C") > 0) {
    c1 <- 2 + sum(ganancia[maquina == "C"])
    c2 <- 2 + abs(sum(ganancia[maquina == "C"] -1))
  }
  
  prob <- c(a1/(a1+a2), b1/(b1+b2), c1/(c1+c2))
  names(prob) <- c("A","B","C")
  
  if (sum(prob == max(prob)) == 1) {
    maq <- names(prob[which.max(prob)])
  } else {
    maq <- sample(names(prob[prob == max(prob)]), size = 1)
  }
  
  return(maq)
  
}
```
:::

\newpage
Simulando los 366 días de juego:

```{r sim gcpp}
sim <- simulacion("gcpp", n = 1)

salida <- salidas(sim)


```

```{r gcpp grafico_ganancias_acumuladas}
#| fig-cap: "Unidades monetarias acumuladas durante un año con la estrategia greedy con probabilidad a posteriori."

salida$grafico_ganancias_acumuladas
```

Se observa que se ganaron `r max(salida$ganancias_acumuladas)` unidades monetarias en el año.

```{r gcpp grafico_barplot}
#| fig-cap: "Frecuencia, éxito y fracaso para cada máquina durante un año con la estrategia greedy con probabilidad a posteriori."

salida$grafico_barplot

maquina_mas_jugada <- salida$tabla_barplot |> group_by(Maquina) |> summarise(n = sum(Cantidad)) |> filter(n == max(n)) |> select(Maquina) |> as.character() 

```

`r ifelse(length(maquina_mas_jugada) == 1, paste("La máquina más jugada fue la", maquina_mas_jugada) ,paste("Las máquinas más jugadas fueron las", paste(maquina_mas_jugada, collapse = " y ")))`

\newpage
```{r gcpp grafico_posteriors}
#| fig-cap: "Probabilidades de éxito para cada máquina a posteriori luego de un año con la estrategia greedy con probabilidad a posteriori."

salida$grafico_posteriors
```

Y así resultan las distribuciones de la probabilidad de éxito en cada máquina a posteriori. 

Ventajas de la estrategia:

  - Se tiene en cuenta toda la informacíon obtenida hasta el momento.
  
  - No se concentra demasiado pronto en explotar.

Desventajas de la estrategia:

  - Explora únicamente en los primeros días.
  
  - Aunque de manera menos frecuente que en el caso anterior, suele explotar la máquina incorrecta.


\newpage
### $\epsilon$-Greedy con tasa observada

Se selecciona con una probabilidad $1-\epsilon$ la máquina que hasta el momento tenga la mayor tasa de éxito observada, y con una probabilidad de $\frac{\epsilon}{2}$ las máquinas restantes. $\epsilon$ es un parámetro de exploración, cuando es igual a $0$ la estrategia es igual a "Greedy con tasa observada", cuando es igual a $1$ es igual a la estrategia "Al azar".

Para elegir la máquina con la que se va a jugar en el día se hizo uso de la siguiente función:

::: {.callout-note}
## Función e_greedy

```{r funcion e_greedy, echo=TRUE, eval=FALSE}
# e-Greedy con tasa observada

e_greedy <- function(maquina, ganancia, param) {
  # Las tazas son 0 en la primera iteracion
  tasa <- numeric(3)
  
  # Cuando una maquina no se usa ni una vez, la tasa va a seguir siendo 0
  if (sum(maquina == "A") > 0) {
    tasa[1] <- sum(ganancia[maquina == "A"])/sum(maquina == "A")
  }
  if (sum(maquina == "B") > 0) {
    tasa[2] <- sum(ganancia[maquina == "B"])/sum(maquina == "B")
  }
  if (sum(maquina == "C") > 0) {
    tasa[3] <- sum(ganancia[maquina == "C"])/sum(maquina == "C")
  }
  
  # Se asigna el nombre de la maquina para cada tasa
  names(tasa) <- c("A","B","C")
  # Se selecciona entre explorar o explotar
  aleatorio <- runif(1)
  
  probs <- c(0,0,0)
  if (aleatorio <= param) {return(sample(names(tasa),size = 1))}else{
    for (i in 1:3) {
      if((tasa == max(tasa))[i]){probs[i] <- 1/sum(tasa == max(tasa))}
    }
    return(sample(names(tasa),size = 1,prob = probs))
  }
}
```
:::

\newpage
Simulando los 366 días de juego:

```{r sim e_greedy}
sim <- simulacion("e_greedy", n = 1)

salida <- salidas(sim)

```

```{r e_greedy grafico_ganancias_acumuladas}
#| fig-cap: "Unidades monetarias acumuladas durante un año con la estrategia e-greedy."

salida$grafico_ganancias_acumuladas
```

Se observa que se ganaron `r max(salida$ganancias_acumuladas)` unidades monetarias en el año.

```{r e_greedy grafico_barplot}
#| fig-cap: "Frecuencia, éxito y fracaso para cada máquina durante un año con la estrategia e-greedy."

salida$grafico_barplot

maquina_mas_jugada <- salida$tabla_barplot |> group_by(Maquina) |> summarise(n = sum(Cantidad)) |> filter(n == max(n)) |> select(Maquina) |> as.character() 

```

`r ifelse(length(maquina_mas_jugada) == 1, paste("La máquina más jugada fue la", maquina_mas_jugada) ,paste("Las máquinas más jugadas fueron las", paste(maquina_mas_jugada, collapse = " y ")))`


```{r e_greedy grafico_posteriors}
#| fig-cap: "Probabilidades de éxito para cada máquina a posteriori luego de un año con la estrategia e-greedy."

salida$grafico_posteriors
```

Y así resultan las distribuciones de la probabilidad de éxito en cada máquina a posteriori. 

Ventajas de la estrategia:

  - La asignación del parámetro $\epsilon$ permite regular hasta que punto se prefiere explorar por sobre explotar o viceversa.
  
  - Con buenos valores de $\epsilon$ se obtiene un buen balance entre explotación y exploración, llevando en muchos casos a buenas ganancias.
  
  - La estrategia nunca comete el error de explotar una sola máquina, ya que siempre existe una probabilidad $\epsilon > 0$ de elegir una máquina al azar.

Desventajas de la estrategia:

  - Valores demasiado altos de $\epsilon$ producen un exceso de exploración y no se aprovecha la información obtenida.
  
  - Valores demasiado pequeños de $\epsilon$ pueden producir que se sobreexplote una mala máquina.


\newpage
### Softmax

Dada la tasa observada para cada máquina ($\pi_{i}$) y el parámetro de temperatura ($\tau$) definido, se calcula una probabilidad de elegir cada una de estas utilizando la función softmax: 

$$Pr(i) = \frac{e^{\pi_i/\tau}}{\sum_{i = 1}^{3}{e^{\pi_i/\tau}}}$$ 

Donde $i$ representa a las máquinas y $\tau$ a diferencia del método $\epsilon$-greedy, en el cual el parámetro determina la probabilidad de explorar o explotar, en este caso determina, de manera inversa, el peso que tendrán las tasas de éxitos observadas hasta el momento de cada máquina al calcular las probabilidades de elegir cada una de estas.

Para elegir la máquina con la que se va a jugar en el día se hizo uso de la siguiente función:

::: {.callout-note}
## Función softmax

```{r funcion softmax, echo=TRUE, eval=FALSE}

# Softmax -------------

softmax <- function(maquina, ganancia, param) {
  
  # Las tasas son 0 en la primera iteracion
  tasa <- numeric(3)
  
  # Cuando una maquina no se usa ni una vez, la tasa va a seguir siendo 0
  # Cuando se juegue al menos una vez su tasa será el numero de veces que gano en la maquina
  # dividido la cantidad de veces que jugo con la maquina
  if (sum(maquina == "A") > 0) {
    tasa[1] <- sum(ganancia[maquina == "A"])/sum(maquina == "A")
  }
  if (sum(maquina == "B") > 0) {
    tasa[2] <- sum(ganancia[maquina == "B"])/sum(maquina == "B")
  }
  if (sum(maquina == "C") > 0) {
    tasa[3] <- sum(ganancia[maquina == "C"])/sum(maquina == "C")
  }
  
  # Se asigna el nombre de la maquina para cada tasa
  names(tasa) <- c("A","B","C")
  
  # Calculo las probabilidades en base a las tasas
  # Como tasa es un vector puedo operar como muestro abajo
  probs <- exp(tasa/param)/sum(exp(tasa/param))
  
  # Directamente pongo el Sample en el return para eficiencia
  
  return(sample(names(tasa),size = 1,prob = probs))
}

```
:::

\newpage

Simulando los 366 días de juego:

```{r sim softmax}
sim <- simulacion("softmax", n = 1)

salida <- salidas(sim)


```

```{r softmax grafico_ganancias_acumuladas}
#| fig-cap: "Unidades monetarias acumuladas durante un año con la estrategia softmax."

salida$grafico_ganancias_acumuladas
```

Se observa que se ganaron `r max(salida$ganancias_acumuladas)` unidades monetarias en el año.

```{r softmax grafico_barplot}
#| fig-cap: "Frecuencia, éxito y fracaso para cada máquina durante un año con la estrategia softmax."

salida$grafico_barplot

maquina_mas_jugada <- salida$tabla_barplot |> group_by(Maquina) |> summarise(n = sum(Cantidad)) |> filter(n == max(n)) |> select(Maquina) |> as.character() 

```

`r ifelse(length(maquina_mas_jugada) == 1, paste("La máquina más jugada fue la", maquina_mas_jugada) ,paste("Las máquinas más jugadas fueron las", paste(maquina_mas_jugada, collapse = " y ")))`


```{r softmax grafico_posteriors}
#| fig-cap: "Probabilidades de éxito para cada máquina a posteriori luego de un año con la estrategia softmax."

salida$grafico_posteriors
```

Y así resultan las distribuciones de la probabilidad de éxito en cada máquina a posteriori. 

Ventajas de la estrategia:

  - Al igual que la estrategia "$\epsilon$-greedy", se le puede asignar valores al parámetro $\tau$ para lograr un equilibrio entre exploración y explotación, y así lograr mayores ganancias.
  
  - Hace uso de la información de las tiradas anteriores.
  
Desventajas de la estrategia:

  - Para valores de $\tau$ muy cercanos a cero, se corre el riesgo de sobreexplotar una máquina 

  - Cuando $\tau \rightarrow \infty$, la estrategia tiende a elegir máquinas al azar.

\newpage
### Upper-Bound

# Redactar cuando estemos seguros  

Para elegir la máquina con la que se va a jugar en el día se hizo uso de la siguiente función:

::: {.callout-note}
## Función UB

```{r funcion upper-bound, echo=TRUE, eval=FALSE}

# Upper-Bound -------------

UB <- function(maquina, ganancia, param) {
  
  # Argumentos de las distribuciones de los parámetros
  a1 <- 2; b1 <- 2; c1 <- 2; a2 <- 2; b2 <- 2; c2 <- 2
  
  if (sum(maquina == "A") > 0) {
    a1 <- 2 + sum(ganancia[maquina == "A"])
    a2 <- 2 + abs(sum(ganancia[maquina == "A"] -1))
  }
  if (sum(maquina == "B") > 0) {
    b1 <- 2 + sum(ganancia[maquina == "B"])
    b2 <- 2 + abs(sum(ganancia[maquina == "B"] -1))
  }
  if (sum(maquina == "C") > 0) {
    c1 <- 2 + sum(ganancia[maquina == "C"])
    c2 <- 2 + abs(sum(ganancia[maquina == "C"] -1))
  }
  
  # Limite superior de 95% credibilidad
  ls <- c(qbeta(1 - param/2, a1, a2), qbeta(1 - param/2, b1, b2),
          qbeta(1 - param/2, c1, c2))
  names(ls) <- c("A","B","C")
  
  # Para elegir el limite superior mayor
  if (sum(ls == max(ls)) == 1) {
    maq <- names(which.max(ls))
    
  } else if (sum(ls == max(ls)) == 2) {
    maq <- sample(names(ls)[ls == max(ls)], size = 1)
    
  } else {
    maq <- sample(names(ls), size = 1)
    
  }
  
  return(maq)
}

```
:::

\newpage 

Simulando los 366 días de juego:

```{r sim upper-bound}
sim <- simulacion("upper_bound", n = 1)

salida <- salidas(sim)


```

```{r upper-bound grafico_ganancias_acumuladas}
#| fig-cap: "Unidades monetarias acumuladas durante un año con la estrategia upper-bound."

salida$grafico_ganancias_acumuladas
```

Se observa que se ganaron `r max(salida$ganancias_acumuladas)` unidades monetarias en el año.

```{r upper-bound grafico_barplot}
#| fig-cap: "Frecuencia, éxito y fracaso para cada máquina durante un año con la estrategia upper-bound."

salida$grafico_barplot

maquina_mas_jugada <- salida$tabla_barplot |> group_by(Maquina) |> summarise(n = sum(Cantidad)) |> filter(n == max(n)) |> select(Maquina) |> as.character() 

```

`r ifelse(length(maquina_mas_jugada) == 1, paste("La máquina más jugada fue la", maquina_mas_jugada) ,paste("Las máquinas más jugadas fueron las", paste(maquina_mas_jugada, collapse = " y ")))`


```{r upper-bound grafico_posteriors}
#| fig-cap: "Probabilidades de éxito para cada máquina a posteriori luego de un año con la estrategia upper-bound."

salida$grafico_posteriors
```

Y así resultan las distribuciones de la probabilidad de éxito en cada máquina a posteriori. 

Ventajas de la estrategia:

  -

Desventajas de la estrategia:

  -
  


\newpage
### Thompson

Se extrae una muestra de la distribución a posteriori de las probabilidades de éxito de cada máquina y se juega con la que se obtenga la muestra más grande.

Para elegir la máquina con la que se va a jugar en el día se hizo uso de la siguiente función:

::: {.callout-note}
## Función thompson

```{r funcion thompson, echo=TRUE, eval=FALSE}

# Thompson -------------

thompson <- function(maquina, ganancia) {
  
  # Argumentos de las distribuciones de los parámetros
  a1 <- 2; b1 <- 2; c1 <- 2; a2 <- 2; b2 <- 2; c2 <- 2
  
  if (sum(maquina == "A") > 0) {
    a1 <- 2 + sum(ganancia[maquina == "A"])
    a2 <- 2 + abs(sum(ganancia[maquina == "A"] -1))
  }
  if (sum(maquina == "B") > 0) {
    b1 <- 2 + sum(ganancia[maquina == "B"])
    b2 <- 2 + abs(sum(ganancia[maquina == "B"] -1))
  }
  if (sum(maquina == "C") > 0) {
    c1 <- 2 + sum(ganancia[maquina == "C"])
    c2 <- 2 + abs(sum(ganancia[maquina == "C"] -1))
  }
  
  
  # Tomo una muestra de cada theta
  muestras <- c(rbeta(1, a1, a2), rbeta(1, b1, b2), rbeta(1, c1, c2))
  # parametros mayores.
  
  names(muestras) <- c("A","B","C")
  # Devuelvo la más grande
  
  return(names(muestras[which.max(muestras)]))
  
}
```
:::


Simulando los 366 días de juego:

```{r sim thompson}
sim <- simulacion("thompson", n = 1)

salida <- salidas(sim)


```

```{r thompson grafico_ganancias_acumuladas}
#| fig-cap: "Unidades monetarias acumuladas durante un año con la estrategia Thompson."

salida$grafico_ganancias_acumuladas
```

Se observa que se ganaron `r max(salida$ganancias_acumuladas)` unidades monetarias en el año.

```{r thompson grafico_barplot}
#| fig-cap: "Frecuencia, éxito y fracaso para cada máquina durante un año con la estrategia Thompson."

salida$grafico_barplot

maquina_mas_jugada <- salida$tabla_barplot |> group_by(Maquina) |> summarise(n = sum(Cantidad)) |> filter(n == max(n)) |> select(Maquina) |> as.character() 

```

`r ifelse(length(maquina_mas_jugada) == 1, paste("La máquina más jugada fue la", maquina_mas_jugada) ,paste("Las máquinas más jugadas fueron las", paste(maquina_mas_jugada, collapse = " y ")))`


```{r thompson grafico_posteriors}
#| fig-cap: "Probabilidades de éxito para cada máquina a posteriori luego de un año con la estrategia Thompson."

salida$grafico_posteriors
```

Y así resultan las distribuciones de la probabilidad de éxito en cada máquina a posteriori. 

Ventajas de la estrategia:

  - Utiliza la información de las tiradas anteriores.
  
  - A medida que pasan los días, la estrategia eligirá con mayor frecuencia a la mejor máquina.

Desventajas de la estrategia:

  - Si las distribuciones a priori del parámetro no se definen adecuadamente, la estrategia puede llevar a conclusiones erróneas en períodos de tiempo que no sean suficientemente largos.

## Comparaciones

```{r e_greedy maximizacion de epsilon, eval=FALSE}
eps <- seq(0.075,0.25,.025)

final <- NULL

for (i in 1:length(eps)) {
  temp <- simulacion("e_greedy",n = 1000,param = eps[i])
  final <- cbind(final, apply(temp$Ganancias,2,sum))
}

colnames(final) <- eps

apply(final, 2, mean)
apply(final, 2, sd)

for (i in 1:length(eps)) {
  for (j in 1:length(eps)) {
    print(mean(final[,i]>=final[,j]))
  }
}


```
Siendo X variable aleatoria que representa la ganancia total en 1 año de juego y estimando las $P(X_\epsilon<X_{\epsilon')}$ para los $\epsilon$ planteados, concluímos que el valor que maximisa la ganancia total esperada es $\epsilon = 0.125$ REVISAR, ESTO DE LA GANANCIA ESPERADA, CREO QUE ESTÁ MAL CONCEPTUALMENTE

```{r softmax maximisando thau, eval=FALSE}
tau <- c(0.8,seq(1,10,1))

final <- NULL

for (i in 1:length(tau)) {
  temp <- simulacion("softmax",n = 1000,param = tau[i])
  final <- cbind(final, apply(temp$Ganancias,2,sum))
}

colnames(final) <- tau

apply(final, 2, mean)
apply(final, 2, sd)

# Por como aumenta la media nos vamos a concentrar en el intervalo (0,1]

tau <- c(seq(0,1,0.05))[-1]

final <- NULL

for (i in 1:length(tau)) {
  temp <- simulacion("softmax",n = 1000,param = tau[i])
  final <- cbind(final, apply(temp$Ganancias,2,sum))
}

colnames(final) <- tau

apply(final, 2, mean)
apply(final, 2, sd)


for (i in 1:length(eps)) {
  for (j in 1:length(eps)) {
    print(mean(final[,i]>=final[,j]))
  }
}

# Tau óptimo 0.1
```


El valor optimo de $\tau$ es 0.1

```{r Comparaciones finales, eval=FALSE}

estrategias_final <- NULL
names(estrategias)

for (i in 1:length(estrategias)) {
  param <- 0.2
  if(names(estrategias)[i] == "e_greedy"){param <- 0.125}
  if(names(estrategias)[i] == "softmax"){param <- 0.1}
  temp <- simulacion(names(estrategias)[i],n = 1000,param = param)
  estrategias_final <- cbind(estrategias_final, apply(temp$Ganancias,2,sum))
  print(paste(i,"de",length(estrategias)))
}

colnames(estrategias_final) <- names(estrategias)

apply(estrategias_final,2,mean)
apply(estrategias_final,2,sd)

for (i in 1:length(estrategias)) {
  print(mean(estrategias_final[,3]>estrategias_final[,i])  )
}

# al_azar        gcto        gcpp    e_greedy     softmax upper_bound    thompson 
#     158.315     168.331     192.170     186.630     184.120     190.452     188.083

```


# Conclusión

# Cosas a agregar

Nombres a las figuras y titulos a los graficos

Box-plots/Histogramas con las ganancias anuales de cada maquina para las 1000 repeticiones para compararlas

<!-- /renewcommand/tablename{Table} -->
<!-- /renewcommand/figurename{Figure} -->
